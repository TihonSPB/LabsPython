# Синтаксис Python

## Комментарии 

```python
# Однострочный в spider Ctrl+1 в PyCharm Ctrl+/ в Notepad++ Ctrl+q

'''
Многострочный
'''

"""
Многострочный
"""
```

---

## Переменные

В python все, это объекты

### Типы данных

```python
a=2 #class 'int'
b='2' #class 'str'
c=2.0 #class 'float'
d=True # class 'bool'
	#значения типа могут принимать: True (истина) или False (ложь).
	#преобразовать логическое к типу int, то True = 1, а False = 0.
	#обратное преобразование 0 = False, а не=0 = True.
	#преобразовать логическое к типу str, то пустая "" = False, а непустая "*" = True.
```

---

### Объявление константы 

Константа записывается заглавными буквами с нижним подчеркиванием вместо пробелов 

Записываются в начале кода, после импорта модулей

Пример:

```python
SECS_IN_MIN = 60
```

---

### Определить тип

Определить тип объекта можно при помощи функции type:

```python
type(a)
type(b)
type(c)

print(type(a))
print(type(b))
print(type(c))
```

---

### Определить идентификатор объекта (хэш код)

Cтрока, характеризующая размещение объекта в памяти

Могут быть разные переменные, но указывать на один объект (один хэш). Эти переменные называться алиасы

```python
id(a)
print(id(b))
```

---

## Операции с переменными

### Ввод переменных

input всегда возвращает строку (str)

```python
s1 = Input()
s2 = input("Подсказка пользователю, что необходимо ввести:")
```

---

### Преобразование типов данных

```python
num1=input(Введите число: ) #input принимает значение как строку
num1=int(num1) #преобразуем в числовое значение
```

```python
int(12.4) #Преобразовывает в целое число -> 12
# long(20) #Преобразовывает в long Python 2.x -> 20L
float(10) #Преобразовывает в число с плавающей точкой -> 10.0
complex(20) #Создает комплексное число -> (20+0j)
str(10) #Преобразовывает в строку -> '10'
tuple("hello") #Преобразовывает в кортеж -> ( "h","e","l","l","o" )
list("Python") #Преобразовывает в список -> [ "P","y","t","h","o","n" ]
dict( [ (1,2), (3,4) ] ) #Создает словарь -> { 1:2, 3:4 }
```

---

### Вывод переменных

```python
str1="Hello "
str2='World'

print(str1) #Hello
print("\"") #напишет ковычки "
print ("One \nTwo \nThree") #каждое слово с новой строки 
# f строки -вывод значений переменных в {}
print(f"Итог: {str1}{str2}\n")  #Итог: Hello World
# r строки -вывод строки как есть, игнорируя \ и спецсимволы 
print(r"Итог: {str1}{str2}\n") #Итог: {str1}{str2}\n
print("""Многострочный текст
учитывает все переносы
в одном предложении""")
```

---

### Удаление переменной

```python
del a
```

---

### Операции с числами

```python
a=9
b=3

a+b #сумма
a-b #разность
a*b #произведение
a/b #частное, ответ будет типа Float
a**b #возведение в степень
a**0.5 # квадратный корень из a
a**(1/b) #корень степени b
a//b # целочисленное деление
a%b # остаток от деления
-a #унарный минус

# 1+2*3**1+1 = 8  сначала выполняется возведение в степень, затем умножение, затем сложение.
# 3**3**3 = 3²⁷ возведения в степень справа налево
```

---

### Операции с числами модуль math

```python
import math #импорт модуля
print(math.pi) #обращение к модулю, вывод 3.141592653589793
```

```python
import math as m #импорт модуля и присваивание ему имени „m”
print(m.pi) #обращение к модулю, вывод 3.141592653589793
```

```python
from math import pi #импорт только pi из модуля math (можно через запятую импортировать несколько или указать *, как все)
print(pi) 
```

```python
#Тригонометрические функции:
x = 0.5 # x - радины
math.sin(x) #вычисляет синус
math.cos(x) #вычисляет косинус
math.tan(x) #вычисляет тангенс
math.asin(x) #вычисляет арксинус
math.acos(x) #вычисляет арккосинус
math.atan(x) #вычисляет арктангенс

#Гиперболические функции:
math.sinh(x) #гиперболический синус
math.cosh(x) #гиперболический косинус
math.tanh(x) #гиперболический тангенс
#обратные гиперболические функции
math.asinh(x)
math.acosh(1) 
math.atanh(x)

#Экспоненциальные и логарифмические функции:
y = 3
math.exp(x) #число Эйлера в степени x

math.log(x) # Натуральный логарифм числа x (основание 'e' по умолчанию)
math.log(x, y) # логарифм числа x по основанию y
math.log10(x) # десятичный логарифм числа x
math.log2(x) # логарифм по основанию 2 числа x
    
#Функции для работы с квадратными корнями:
math.sqrt(x) #квадратный корень из числа

math.pow(x, y) #x в степени y

#Функции для работы с числами с плавающей запятой:
math.ceil(x) #округление вверх
math.floor(x) #округление вниз
math.trunc(x) # отбрасывание дробной части, округление к нулю
math.fabs(x) # абсолютное значение числа x

#Функции для вычисления факториала и двойного факториала:
math.factorial(3) #факториал числа x
math.gamma(x) # гамма-функция числа x (аналогична факториалу для нецелых чисел)
math.lgamma(x) # натуральный логарифм модуля гамма-функции числа x

#Функции для работы с комплексными числами
math.isinf(x) # проверяет, является ли x бесконечностью
math.isnan(x) # проверяет, является ли x NaN (Not a Number)

#Константы:    
math.pi #константа, Пи
math.e #константа, число Эйлера
```

---

### Операции над строками

```python
string1 = 'This is a string.'
string2 = " This is another string."
a=2

con=string1+string2 #конкатенация 

string1*a #реплицирование. повторение a раз, значение a должно быть целого типа. 

print(len(string1)) #len() - определяет длину строки;
print(string1.title()) #title() - преобразует первый символ каждого слова в строке к верхнему регистру;L
print(string1.lower()) #lower() - символы строки преобразуются к нижнему регистру;
print(string1.upper()) #upper() - символы строки преобразуются к верхнему регистру;
print(string1.capitalize()) #capitalize() - первый символ строки в заглавную букву, а остальные символы в строчные
print(string1.find("k")) #find("0") - проверяет, присутствует ли символ указывает индекс, -1 отсутствует
print(string1.rstrip()) #rstrip() – удаляются пробелы в конце строки;
print(string1.lstrip()) #lstrip() – удаляются пробелы в начале строки;
print(string1.strip()) #strip() - удаляются пробелы с обоих концов;
print(string1.strip('T')) #strip('0') - удаляются с обоих концов указанные символы в параметре функции.

print(string1[2]) # извлекается символ ‘i’
print(string1[1:3]) # извлекаются символы ‘hi’. срез(slicing) варианты: string1[1:], string1[:3], string1[:], string1[1:5:2] 
```

---

## Списки (list)

```python
list1 = []
list1 = ['Hello', 5, 8.2, True]
list1 = [82,8,23,97,92,44,17,39,11,12]
print(len(list1)) #len() - определяет длину списка;
print(list1[1]) # вывод символа индекса [1]. вывод 8
list1.insert(3,20) #  вставляет элемент 20 в список по указанному 3
list1.append(6) # добавляет элемент в конец списка
list1.pop(1) # Удаляет элемент с индексом 1
list1.remove(8) # удаляет первое вхождение указанного элемента из списка (удалит число 8). Не найден, метод вызывает исключение ValueError.
list1.reverse() # меняет порядок элементов в списке на обратный
list1.sort() # сортирует в порядке возрастания. Список содержит строки, будут отсортированы в лексикографическом порядке.
list1.clear() #очистить весь список.

list2 = [3,5,6,2,33,6,11]
lis = sorted(list2) # сортирует в порядке возрастания не меняя исходный список.
print(lis) # выводит: [2, 3, 5, 6, 6, 11, 33]
print(' '.join(map(str, lis))) # выводит: 2 3 5 6 6 11 33
```

Распаковка списка

```python
my_list = [1, 2, 3]
x, y, z = my_list
print(x) # 1
print(y) # 2
print(z) # 3

a, b, *c, d = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a) # 1
print(b) # 2
print(c) # [3, 4, 5, 6, 7, 8]
print(d) # 9
```

Удобный способ создания списков, содержимое которых подчиняется правилу

```python
a = [x+3 for x in range (5, 10)] # создает список [8, 9, 10, 11, 12]
cubes = [i**3 for i in range(5)] # создает список [0, 1, 8, 27, 64]
nums = [i*2 for i in range(10)] # создает список 10 четных [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
evens = [i*2 for i in range(10) if i**2 % 2 == 0] # создает список [0, 4, 8, 12, 16]
```

---

## Срезы

*(0)* __[0||-4]__ *(1)* __[1||-3]__ *(2)* __[2||-2]__ *(3)* __[3||-1]__ *(4)*

Начальный индекс включается. Конечный индекс исключается.

```python
animals = ["cat", "dog", "bird", "cow"]
print(animals[1:3]) # ['dog', 'bird'] с индекса 1, без индекса 3
print(animals[:3]) # ['cat', 'dog', 'bird'] с первого элемента [0], без [3]
print(animals[1:]) # ['dog', 'bird', 'cow'] с индекса 1, до последнего элемента
print(animals[-2]) # bird Предпоследний элемент
print(animals[-3:]) # ['dog', 'bird', 'cow'] последние 3 элемента
print(animals[-3:-1]) # ['dog', 'bird'] с индекса [-3], без индекса [-1]
```

---

## Кортежи (tuple)

Последовательность данных, которые невозможно изменить.

```python
seq = (2,8,23,97,92,44,17,39,11,12)
print(seq.count(8)) # возвращает количество вхождений указанного значения
print(seq.index(44)) # возвращает индекс первого вхождения указанного значения
listseq = list(seq) # Преобразует кортеж к типу «список»
print(type(listseq)) # Выводит <class 'list'>
```

Распаковка кортежа

```python
my_tuple = (1, 2, 3)
x, y, z = my_tuple
print(x) # 1
print(y) # 2
print(z) # 3

a, b, *c, d = (1, 2, 3, 4, 5, 6, 7, 8, 9)
print(a) # 1
print(b) # 2
print(c) # [3, 4, 5, 6, 7, 8]
print(d) # 9
```

---

## Словари (dict)

Любой объект Python, может стать значением в словаре.

```python
D = {
     'food': 'Apple', 
     'quantity': 4, 
     'color': 'Red',
     }

print(D['food']) # Выводит значение Apple, по ключу food
D['quantity']+=10 # Добавляет значению 4+10, по ключу quantity
print(D['quantity'])  # Выводит значение 14, по ключу quantity
     
# in, not in Проверка наличия ключа в словаре
print('color' in D) # True ключ color присутствует в словаре D
print(4 not in D) # True ключ 4 отсутствует в словаре D

# Функция get если ключ не представлен в словаре / списке, возвращает другое указанное значение
print(D.get(4)) # None
print(D.get(4, "not found")) # not found
print(D.get('food', "not found")) # Apple
```

Пример:

```python
dp = {} # пустой словарь
count = int(input("Количество записей: "))
for i in range(count):
    name = input("Имя "+str(i+1)+": ")
    age = int(input("Возраст "+str(i+1)+": "))
    dp[name] = age
print(dp)
```

Пример Вложенность хранения данных:

```python
rec = {'name': {'firstname': 'Bob', 'lastname': 'Smith'},
       'job': ['dev', 'mgr'],
       'age': 25}
rec['job'].append('janitor') # добавляем в список должностей
# print(rec)
print("Имя: "+rec['name']['firstname'])
print("Фамилия: "+rec['name']['lastname'])
print("Возраст: "+str(rec['age']))
print("Должности: "+' '.join(rec['job']))
```

---

## Множества (set)

Множества неупорядочены, они не могут быть проиндексированы

```python
a = {1, 2, 3, 4, 5, 6}
b = {4, 5, 6, 7, 8, 9}

a.add(7) # {1, 2, 3, 4, 5, 6, 7} добавление новых элементов. Дублирующиеся автоматически удаляются
a.remove(7) # {1, 2, 3, 4, 5, 6} удаление конкретного элемента

print(3 in a) # True 3 присутствует в множестве a
print(3 not in b) # True 3 отсутствует в множестве b

print(a | b) # {1, 2, 3, 4, 5, 6, 7, 8, 9} Оператор объединения | соединяет два множества
print(a & b) # {4, 5, 6} Оператор пересечения & получает элементы, которые есть в обоих множествах
print(a - b) # {1, 2, 3} Оператор разности - получает элементы, которые есть в первом множестве, но которых нет во втором
print(b - a) # {8, 9, 7}
print(a ^ b) # {1, 2, 3, 7, 8, 9} Оператор симметричной разности ^ получает элементы, которые есть либо в одном множестве, либо в другом, но не в обоих сразу
```

---

## Логика

### Операторы сравнения

```
<	Меньше — условие верно, если первый операнд меньше второго.
>	Больше — условие верно, если первый операнд больше второго.
<=	Меньше или равно — условие верно, если первый операнд меньше или равен второму.
>=	Больше или равно — условие верно, если первый операнд больше или равен второму.
==	Равенство. Условие верно, если два операнда равны.
!=	Не равно.
```

Пример:

```python
(x * x < 1000)
(2 * x != y)
(a == b == c)
(1 <= x <= 10)
```

Пример сравнения переменных:

```python
s1 = "Hello"
so = "o"
s2 = "Hell" + so
s3 = "Hell" + "o"

print(f"s1 и s2. Сравнение содержимого: {s1 == s2}\n") #True
print(f"s1 и s2. Сравнение объектов по ссылке: {s1 is s2}\n") #False эквивалентно id(s1)==id(s2)
print(f"s1 и s3. Сравнение содержимого: {s1 == s3}\n") #True
print(f"s1 и s3. Сравнение объектов по ссылке: {s1 is s3}\n") #True эквивалентно id(s1)==id(s3)
```

---

### Логические операторы

```
and
or
not
```

---

### Ветвление

```
if Условие:
    Блок_инструкций_1 (или pass пустой оператор)	
else:
    Блок_инструкций_2 (или pass пустой оператор)
```
	
Блок_инструкций_1 будет выполнен, если Условие истинно. Если Условие ложно, будет выполнен Блок_инструкций_2.

Пример:

```python
x=-5
if x < 0:
    x = -x
print(x)
```

---

### Каскадные условные инструкции if... elif... else:

```python
print('введите координату x:')
x = int(input())
print('введите координату y:')
y = int(input())
if x > 0 and y > 0:
    print("Первая четверть")
elif x > 0 and y < 0:
    print("Четвертая четверть")
elif y > 0:
    print("Вторая четверть")
else:
    print("Третья четверть")
```
	
Условия if, ..., elif проверяются по очереди. Если все ложны, выполняется else

---

### Тернарный оператор

```python
status  = 1
msg = "Logout" if status == 1 else "Login"

print(msg) # Logout
```

---

### Цикл while «пока»

```
while Условие:
    Блок_инструкций (или pass пустой оператор)
```

Пока условие истинно выполняется инструкция

Пример:

```python
a = 1
n = 10
while a <= n:
    print(a)
    a += 1
```

---

### Цикл for 

Краткая альтернатива циклу while

Пример 1:

```python
for i in range(10):
   print(i)
   
#соответствуют циклу while:
i = 0
while i < 10:
  print(i)
  i += 1
```

Пример 2 (start, stop, step):

```python
for i in range(20, 10, -2):
	print(i)
	
#соответствуют циклу while:
i = 20
while i > 10:
  print(i)
  i -= 2
```

---

## Исключения

Распространенные исключения:  
- ZeroDivisionError: деление на ноль
- ImportError: ошибка импорта;
- IndexError: список проиндексирован с номером вне допустимого диапазона;
- NameError: используется неизвестная переменная;
- SyntaxError: код не может быть проанализирован должным образом;
- TypeError: функция вызывается для значения несоответствующего типа;
- ValueError: функция вызывается для значения правильного типа, но с несоответствующим значением

---

### Обработка исключений

Синтаксис:

```
try:
    Код, который может вызвать исключение
    Если исключение возникнет, код в блоке try перестанет выполняться.
except тип обрабатываемого исключения:
    Если исключение возникнет, выполнится код в блоке except.
    Ошибка не возникнет, код в блоке except не выполнится.
except (Множественные исключения в одном блоке, через запятую):
    Если исключения возникнут, выполнится код в блоке except.
```

Конструкция except без указанного исключения будет перехватывать все ошибки.  
Следует использовать с осторожностью, может выявить неожиданные ошибки и скрыть ошибки в коде.

```
try:
    Код, который может вызвать исключение
except:
    Если исключение возникнет, выполнится код в блоке except.
```

---

### Блок finally

Блок finally выполняется независимо, возникло исключение или нет.  
Полезен при работе с файлами и ресурсами: убедиться, что файлы или ресурсы будут закрыты или освобождены

```python
try:
    print(5/0)
except ZeroDivisionError:
    print("Ошибка! Деление на ноль")
finally:
    print("Программа завершена")
```

---

### Блок else

Блок else выполнится только, если не возникнет ошибки в конструкции try  

```python
try:
    print(1)
except ZeroDivisionError:
    print("Ошибка! Деление на ноль")
else:
    print(2)
```

---

### Вызов исключений оператор raise

Можно вызвать исключение, когда это необходимо

```python
num = 150
if num > 100:
    raise ValueError("Описание исключения")
```

---

## Функции

Функции — это готовые кирпичики, из которых строится программа.

Стандартные функции (print, input, функции модуля turtle)

```
def Имя_функции(параметр_1, параметр_2, ...):
    Блок_операций (или pass пустой оператор)
```

Пример:

```python
def hello(): #функция без аргумента (выводит текст на экран)
    print('Hello, world!') #тело функции

hello() #Вызов функции
```

Пример не возвращает результат:

```python
def hello(name): #функция не возвращает результат (выводит текст на экран)
    print('Hello, ', name, '!') #тело функции

hello('world') #Вызов функции
```

Функция со значением аргумента по умолчанию:

```python
def hello(name='world'): # Значения по умолчанию должны следовать за именованными параметрами, которым не были присвоены значения по умолчанию
    print('Hello,', name,'!') #тело функции

hello('Tihon') # Hello, Tihon !
hello() # Hello, world !
```

Функция с переменным числом аргументов:

```python
def function(named_arg, *args): # *args должен следовать после именованных параметров функции
    print(named_arg) # 1
    print(args) # (2, 3, 4, 5)

function(1, 2, 3, 4, 5)
```

Пример возвращает результат:

```python
def sum(a, b): #функция возвращает результат (оператор return)
    return a + b

sum(1, 2) #возвращает значение 3
sum(5, -7) #возвращает значение -2
```

Несколько возвращаемых значений:

```python
def rect(length, width):
  area = length * width
  perimeter = 2 * length + 2 * width
  return area, perimeter
 
my_area, my_perimeter = rect(5, 8) # Возвращает my_area = 40, my_perimeter = 26
```

---

### Спецификация функции

Для читаемости и объяснения работы функции делается спецификация.

После объявления функции набрать """ и Enter. Будет создан шаблон спецификации.

Пример:

```python
def sum(a, b): 
    '''
    Parameters
    ----------
    a : TYPE
        DESCRIPTION.
    b : TYPE
        DESCRIPTION.

    Returns
    -------
    TYPE
        DESCRIPTION.
    '''
    return a + b
```

---

### Лямбда (ананимные) функции

```python
# Лямбда функция
print((lambda x: x**2 + 5*x + 4) (-4))

# Аналог именной функции
def polynomial(x):
    return x**2 + 5*x + 4
print(polynomial(-4))
```

Пример передачи лямбда функции

```python
def my_func(f, arg): # принимает f = lambda x: 2*x*x, arg = 5
  return f(arg) # возвращает (lambda x: 2*x*x)(5) => 2*5*5 = 50

lam = my_func(lambda x: 2*x*x, 5)
print(lam) # 50
```

---

### Функция map

Функция для работы со списками или подобными объектами

Пример с передачей в функцию каждого аргумента списка

```python
def add_three(x):
    return x + 3

nums = [10, 15, 20, 25]
result = list(map(add_three, nums))
print(result) # [13, 18, 23, 28]
```

Пример с использованием lambda

```python
nums = [10, 15, 20, 25]
result = list(map(lambda x: x + 3, nums))
print(result) # [13, 18, 23, 28]
```

---

### Функция filter

Функция для работы со списками или подобными объектами

Фильтрует итерируемый объект, оставляя только элементы, которые соответствуют условию

```python
nums = [10, 15, 20, 25]
result = list(filter(lambda x: x%2==0, nums))
print(result) # [10, 20]
```

---

### Декораторы

Функции которые расширяют функциональность функций, которые не хотите изменять.

```python
def decor(func): # функция принимает функцию
    def wrap():
        print("============")
        func()
        print("============")
    return wrap

def print_my_text():
    print("My text")

noDecorated = print_my_text
noDecorated()
   
decorated = decor(print_my_text)
decorated()
```

Пример присваивания декоратора к функции @

```python
def decor(func): # функция принимает функцию
    def wrap():
        print("============")
        func()
        print("============")
    return wrap

@decor
def print_my_text():
    print("My text")

print_my_text()
```

---

### Рекурсия 

Рекурсия когда функции вызывают сами себя. 

```python
def factorial(x):
    if x == 1:
        return 1
    else: 
        return x * factorial(x-1)

print(factorial(5))
```

---

## ООП

### Класс

Имя класса с большой буквы, имена классов должны быть в стиле CapWords

```python
class Cat: # класс Cat
    
    legs = 4 # статический атрибут
    
    # методы - функции внутри класса
    # метод __init__ вызывается когда создаеться экземпляр (объект), где указываются свойства (атрибуты)
    def __init__(self, name, wool_color, eyes_color):
        self.name = name
        self.wool_color = wool_color
        self.eyes_color = eyes_color

    # действия (методы объектов), которые способен совершать класс. 
	# Вызывается экземпляром класса, затем передается в параметр метода self.
    
    # Мурлыкать
    def purr(self):
        print("Муррр!")
    
    # Шипеть
    def hiss(self):
        print("Кот по кличке " + self.name + " сказал: Шшшшшш!")
```

Работа с объектом на основе класса

```python
# Создание объекта
my_cat = Cat("Барсик", "Рыжий", "Зеленые") # новый объект с атрибутами

# Вывод атрибутов
print(my_cat.name) # Барсик
print(my_cat.wool_color) # Рыжий
print(my_cat.eyes_color) # Зеленые
print(my_cat.legs) # 4

# Изменение атрибута объекта
my_cat.wool_color = "Белый"
print(my_cat.wool_color) # Белый

# Обращение к методам объекта
my_cat.purr() # Муррр!
my_cat.hiss() # Кот по кличке Барсик сказал: Шшшшшш!
```

---

### Наследование

```python
# Суперкласс 
class Animal: 
    def __init__(self, name, color):
        self.name = name
        self.color = color

# Классы наследники
class Cat(Animal):
    def voice(self):
        print("Муррр!")
        
class Dog(Animal):
    def voice(self):
        print("Гав!")

# Создание объекта        
my_dog = Dog("Шарик", "Черный")
my_cat = Cat("Мурзик", "Белый")

# Обращение к методам объекта
my_cat.voice() # Муррр!
my_dog.voice() # Гав!
```

---

### Перегрузка операторов Магические методы

| Метод | Оператор |
| ----- | -------- |
| \_\_add\_\_ | + |
| \_\_sub\_\_ | - |
| \_\_mul\_\_ | *  |
| \_\_truediv\_\_ | / |
| \_\_floordiv\_\_ | // |
| \_\_mod\_\_ | %  |
| \_\_pow\_\_ | ** |
| \_\_and\_\_ | & |
| \_\_xor\_\_ | ^ |
| \_\_or\_\_ | \| |
| \_\_lt\_\_  | < |
| \_\_le\_\_ | <= |
| \_\_eq\_\_ | == |
| \_\_ne\_\_ | != |
| \_\_gt\_\_ | > |
| \_\_ge\_\_ | >= |
| \_\_len\_\_ | для len() |
| \_\_getitem\_\_ | для индексирования |
| \_\_setitem\_\_ | для присваивания индексированных значений |
| \_\_delitem\_\_ | для удаления индексированных значений |
| \_\_iter\_\_ | для итерации по объектам (например, в циклах for) |
| \_\_contains\_\_ | для in |
| ... | и т.д. |

Пример перегрузки "+" (\_\_add\_\_):

```python
class Vector2:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    #метод __add__ определяет поведение оператора + в классе Vector2    
    def __add__(self, other):
        return Vector2(self.x + other.x, self.y + other.y)
   
v_1 = Vector2(3, 8)
v_2 = Vector2(4, 5)

v_result = v_1 + v_2 # Складываем два объекта класса.

print(v_result.x, v_result.y) # 7 13
```

---

### Инкапсуляция. Сокрытие данных

В python нет способов принудительно сделать метод или атрибут строго приватным.

Условно частные методы и атрибуты оформляются с единым подчеркиванием в начале имени. \_имя  
Строго частные методы и атрибуты оформляются с двойным подчеркиванием в начале имени. \_\_имя  

```python
class Cat:
    _legs = 4 #Условно частный атрибут
    
    def __init__(self, name):
        self.__name = name # Строго частный атрибут
        
    def print_number_paws(self):
        print(self._legs)
        
    def print_name(self):
        print(self.__name)

# Создание объекта
cat = Cat("Барсик")

# Обращение к методам объекта
cat.print_number_paws()
cat.print_name()

print(cat._legs) # 4 Получить доступ к условно частному атрибуту 
print(cat._Cat__name) # Барсик Получить доступ к строго частному атрибуту
```

---

### Методы класса

Методы класса вызываются классом, который передается параметру cls метода.  
Методы класса оформляются с декоратором classmethod.

```python
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def calculate_area(self):
        return self.width * self.height

    # Метод класса и вызывается для класса, а не для экземпляра класса. Он возвращает новый объект класса cls.
    @classmethod
    def new_square(cls, side_length): # метод класса для создания квадрата, принимает один аргумент (длина стороны квадрата)
        #  создает новый объект класса Rectangle, передавая side_length как ширину и высоту, тем самым создавая квадрат.
        return cls(side_length, side_length)

square = Rectangle.new_square(5) # вызывается метод класса new_square, который создает объект Rectangle с шириной и высотой, равными 5
print(square.calculate_area()) # 25
```

---

### Статические методы

Статические методы полезны для создания функций, которые логически относятся к классу, но не зависят от его состояния.  
Они аналогичны обычным функциям класса с тем отличием, что вы можете вызывать их экземпляром класса. Работают только с переданными им аргументами.  
Статические методы оформляются с декоратором staticmethod.  
Статические методы можно вызвать, не создавая объект класса.

```python
class Calculator:
    
    @staticmethod
    def add(n1, n2):
        return n1+n2
        
n1 = 3
n2 = 6

print(Calculator.add(n1, n2)) # 9
```

---

### Свойства

Свойства это инструмент для управления доступом к атрибутам класса.  
Свойства оформляются с декоратором property  

```python
class Circle:
    def __init__(self, radius):
        self.radius = radius  # Используем сеттер для установки радиуса

    @property
    def radius(self): # Метод позволяет получать значение атрибута _radius как обычное свойство: circle.radius
        # Геттер для радиуса.
        return self._radius

    @radius.setter
    def radius(self, value): # Метод позволяет устанавливать значение атрибута _radius с проверкой
        # Сеттер для радиуса.
        if value < 0:
            raise ValueError("Радиус не может быть отрицательным")
        self._radius = value

    @property
    def area(self): # Метод вычисляет площадь круга на лету, используя текущее значение радиуса.
        return 3.14159 * self._radius ** 2

# Использование
circle = Circle(5)
print(circle.radius)  # Вывод: 5
print(circle.area)    # Вывод: 78.53975 (вычислено автоматически)

# Попытка установить отрицательный радиус
try:
    circle.radius = -10
except ValueError as e:
    print(e)  # Вывод: Радиус не может быть отрицательным
```

---

## Регулярные выражения

модуль re  
Регулярные выражения - средство для работы со строками.  
используются для:  
   - проверки соответствтя строки определенному набору символов (например, имеет ли строка формат адреса электронной почты)  
   - выполнения замены внутри строки (например, исправить правописание слова во всех его упоминаниях).

```python
import re

pattern = r"spam"

# Функция re.match определяет, есть ли совпадение в начале строки.
if re.match(pattern, "eggspamsausagespam"): # Совпадений нет
    print("Найдено совпадение")
else:
    print("Совпадений нет")

# Функция re.search используется для поиска набора символов в любом месте строки.    
if re.search(pattern, "eggspamsausagespam"): # Найдено совпадение
    print("Найдено совпадение")
else:
    print("Совпадений нет")

# Функция re.findall возвращает список всех подстрок, которые совпадают с искомым набором символов.
print(re.findall(pattern, "eggspamsausagespam")) # ['spam', 'spam']

# Поиск с регулярными выражениями возвращает объект с несколькими методами, содержащими информацию об объекте.
my_serch = re.search(pattern, "eggspamsausagespam")
if my_serch:
    # метод group, возвращает совпавшую строку
    print(my_serch.group()) # spam
    # методы, start и end, возвращающие начальную и конечную позицию первого совпадения
    print(my_serch.start()) # 3
    print(my_serch.end()) # 7
    # # метод span, возвращающий начальную и конечную позицию первого совпадения в виде кортежа.
    print(my_serch.span()) # (3, 7)
```

Метод sub используется для поиска и замены текста в строке на основе регулярного выражения.

Синтаксис:

```
re.sub(pattern, repl, string, count=0, flags=0)
```

- pattern: Что нужно искать в строке.  
- repl: Строка или функция, на которую будет заменено найденное совпадение.  
- string: Строка, в которой будет производиться поиск и замена.  
- count (опционально): Максимальное количество замен. По умолчанию 0, означает замену всех совпадений.  
- flags (опционально): Флаги для управления поведением регулярного выражения (например, re.IGNORECASE для игнорирования регистра).  

Пример:

```python
import re

text = "Python is great. I love PYTHON."
result = re.sub(r"python", "JavaScript", text, flags=re.IGNORECASE) # все вхождения слова "python" независимо от регистра
print(result) # JavaScript is great. I love JavaScript.
```

---

### Метасимволы

благодаря метасимволам регулярные выражения эффективней обычных строковых методов.  
«сырая» строка - обычная строка, начинающуюся с «r».

. (точка) - любой символ, исключая символ новой строки

Пример:

```python
import re

pattern = r"gr.y"

if re.match(pattern, "grey"): # True
    print("Match 1") 

if re.match(pattern, "gray"): # True
    print("Match 2") 

if re.match(pattern, "blue"): # False
    print("Match 3")
```
    
^ - начало строки  
$ - конец строки

```python
pattern = r"^gr.y$" # строка должна начинаться с gr, в середине содержать любой символ, за исключением символа новой строки, заканчиваться на у.
```

\* \- ноль или более упоминаний объекта поиска

```python
pattern = r"egg(spam)*" # будут найдены строки, начинающиеся с «egg», за которой следует (или нет) неограниченное число упоминаний «spam». "egg" - True; "eggspamspamegg" - True
```

\+ \- одно (или более) упоминание объекта поиска

```python
pattern = r"g+" # "g" - True; "gggggggggggggg" - True
```

? - ноль повторений или одно повторение

```python
pattern = r"ice(-)?cream" # "ice-cream" - True; "icecream" - True
```

| - «или» красный|синий вернется либо «красный» или «синий»

```python
pattern = r"gr(a|e)y" # "gray" - True; "grey" - True; "griy" - False
```

{х, у} - упоминания объекта поиска между х и у

```python
pattern = r"9{1,3}$" # "9" - True; "999" - True
```

---

### Классы символов

Классы символов поиск конкретного символа из набора символов.

```python
pattern = r"[aeiou]" # будут найдены все строки, содержащие хотя бы один символ с набора.
```

класс [a-z] - поиск любой строчной буквы  
класс [G-P] - поиск любого символа верхнего регистра от G до P  
класс [0-9] - поиск любой цифры.  
класс [A-Za-z] - поиск любой буквы алфавита верхнего или нижнего регистра.  

Пример:

```python
import re

pattern = r"[A-Z][A-Z][0-9]"

if re.search(pattern, "LS8"): # True
    print("Match 1")

if re.search(pattern, "E3"): # False
    print("Match 2")

if re.search(pattern, "1ab"): # False
    print("Match 3")
```

инвертировать класс символов, нужно поместить ^ в начало определения класса

Пример:

```python
import re

pattern = r"[^A-Z]" # ищет любой символ, кроме символов класса. символ ^ должен быть внутри скобок.

if re.search(pattern, "this is all quiet"): # True
    print("Match 1")

if re.search(pattern, "AbCdEfG123"): # True
    print("Match 2")

if re.search(pattern, "THISISALLSHOUTING"): # False
    print("Match 3")
```

---

### Группы

Группа создается путем заключения части регулярного выражения в круглые скобки ().

```python
pattern = r"egg(spam)*" # (spam) представляет собой группу внутри набора символов
```

Функция group

group(0) или group() - метод возвращает все найденные совпадения  
group(n), где n больше 0 - метод возвращает n-ю группу, считая слева.  
groups() - метод возвращает все группы, начиная с первой.

Пример:

```python
import re

pattern = r"a(bc)(de)(f(g)h)i"

match = re.match(pattern, "abcdefghijklmnop")
if match:
    print(match.group()) # abcdefghi
    print(match.group(0)) # abcdefghi
    print(match.group(1)) # bc
    print(match.group(2)) # de
    print(match.groups()) # ('bc', 'de', 'fgh', 'g')
```

Именованные группы 

group(name) - метод возвращает группу по имени.  
Формат: (?P\<name\>...) - где name - имя группы, а ... - содержание группы.  

«незахватывающие» группы. Их нельзя получить по методу группы, поэтому их можно добавлять в регулярное выражение, не нарушая нумерацию.  
Формат: (?:...) - где ... - содержание группы. 

Пример:

```python    
import re

pattern = r"(?P<first>abc)(?:def)(ghi)"

match = re.match(pattern, "abcdefghi")
if match:
    print(match.group("first")) # abc
    print(match.groups()) # ('abc', 'ghi')
```

---

### Специальные последовательности

\\ - бэкслэш, за которым следует другой символ.  
\\n - где n число между от 1 до 99  

Пример:

```python
import re

pattern = r"(.+) \1" #  (.+) \1 - не то же самое, что (.+) (.+), \1 относится к подвыражению первой группы

match = re.match(pattern, "word word") # True
if match:
    print ("Match 1")

match = re.match(pattern, "?! ?!") # True
if match:
    print ("Match 2")    

match = re.match(pattern, "abc cde") # False
if match:
    print ("Match 3")
```

\\d - digits цифры В режиме ASCII им соответствуют [0-9].  
\\D - противоположное значение совпадет с любыми символами, кроме цифр  
\\s - spaces пробелы В режиме ASCII им соответствуют [ \\t\\n\\r\\f\\v].  
\\S - противоположное значение совпадет с любыми символами, кроме пробелов  
\\w - word characters символы слов В режиме ASCII им соответствуют [a-zA-Z0-9_].  
\\W - противоположное значение совпадет с любыми символами, кроме символов  

Пример:

```python
import re

pattern = r"(\D+\d)" # будет искать один (или несколько) нецифровых символов с последующей цифрой.

match = re.match(pattern, "Hi 999!") # True
if match:
    print("Match 1")

match = re.match(pattern, "1, 23, 456!") # False
if match:
    print("Match 2")

match = re.match(pattern, " ! $?") # False
if match:
    print("Match 3")
```

\\A - начало строки  
\\Z - конец строки  
\\b - соответствует пустой строке между символами  

---

Пример Извлечение адресов электронной почты:

```python
import re

str = "Please contact tihon.spb@tihon.com for assistance"

# три группы: 
# 1 - первая часть адреса электронной почты
# 2 - доменное имя без суффикса
# 3 - суффикс доменного имени
pattern = r"([\w\.-]+)@([\w\.-]+)(\.[\w\.]+)" # [\w\.-]+ соответствует одному или более символу

match = re.search(pattern, str) # Если строка содержит несколько адресов re.findall
if match:
    print(match.group())
```

---

## __main__

```python
def function():
    print("импортируемый модуль")

if __name__=="__main__":
    print("сценарий с некоторой функциональностью") # будет недоступной, если этот код будет импортирован в качестве модуля
```

---

## Свой модуль для python

Модулем служит любой файл с расширением .py 

Название модуля с маленькой буквы

Пример наименования файла my_modul.py

Пример объявления переменной в модуле:

```python
a = 351
```

Пример подключения модуля:

```python
import my_modul #импорт модуля находящегося в директории программы 
print(my_modul.a) #обращение к модулю, вывод переменной a
```

```python
import sys #импорт модуля для возможности указания пути 
sys.path.append(r'C:\Путь к каталогу проекта')
import my_modul #импорт модуля по пути
print(my_modul.a) #обращение к модулю, вывод переменной a
```

```python
import my_modul as m #импорт модуля и присваивание ему имени „m”
print(m.a) #обращение к модулю, вывод переменной a
```

```python
from my_modul import a #импорт только переменной a из модуля my_modul (можно через запятую импортировать несколько или указать *, как все)
print(a) 
```